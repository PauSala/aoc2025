## AOC-2025 day 2, part 2

For part two, we are given a list of ranges, for example:

```Rust
let input =
    [
        (851786270, 851907437),
        (27, 47),
        (577, 1044)
    ]
```

## Task

- Given a range, find all elements made of at least one repeating sequence:
  - A matching element is any number consisting of `k` chars repeated `m` times
  - 111 -> 1 repeated 3 times (m = 1, k = 3)
  - 5050 -> 50 repeated 2 times (2, 3)
- Sum all matching elements in the range
- Sum the results for all ranges

---

## Solution

### Pairs k and m

Given a range, we need to check all possible patterns of length `L` in this range.

- For example, if range is `[10, 9999]`, we need to check for:
  - L = 2 => 11, 22, 33, ..., AA
  - L = 3 => 111, 222, 333, ..., AAA
  - L = 4 => 1111, 1212, 1313, ..., 2121, 2222, ..., 3131, ..., ABAB (where A can be equal to B).

Which translates to check every valid pair `( k = num_chars, m = repetitions )` allowed by the range:

- For the range `[10, 9999]`, we have a min length of 2 and max of 4
- we get (k, m):
  - `l = 2 => (1, 2),  l = 3: (1, 3),  l = 3: (2, 2), (1, 4)`
  - Which is basically the list of divisors of each length, excluding the case where m = 1, since k chars repeated 1 time is not a valid setup.

### Observations

The first nice trick is the observation that this numbers can be expressed as:
N = S ( 1 + 10$^{k}$ + 10$^{2k}$ + ... + 10$^{(m - 1)k}$)

##### Examples

k = 1, m = 4, S = 9, N = 9999
N = 9 \* (1 + 10$^{1}$ + 10$^{2}$ + 10$^{3}$) = 9(1 + 10 + 100 + 1000) = 9 \* 1111

Note that what we are doing is calculating those values and adding them up:
123_123_123:
`k = 3, m = 3` -> k determines the size of the shifting, in this case: 123 * (1 + 10$^{1*3}$ + 10$^{2*3}$)

- 123 \* 1_000_000 = 123_000_000
- 123 \* 1000 = 123_000
- 123 \* 1 = 123

#### Geometric series
This:

- N = S ( 1 + 10$^{k}$ + 10$^{2k}$ + ... + 10$^{(m - 1)k}$)

Is a [geometric series](https://en.wikipedia.org/wiki/Geometric_series), and can be expressed as:
For a geometric series:

\[
\sum_{i=0}^{m-1} r^i = \frac{r^m - 1}{r - 1}
\]

Substitute \( r = 10^k \):

\[
1 + 10^k + \cdots + 10^{(m-1)k}
= \frac{10^{km} - 1}{10^k - 1}
\]

So finally we have that: 
\[
    N = S \frac{10^{km} - 1}{10^k - 1}
\]
or
\[
S = N / \frac{10^{km} - 1}{10^k - 1}
\]

lets introduce d (denominator): 
\[
 d = \frac{10^{km} - 1}{10^k - 1}
\]

and

\[
    S = N / d
\]


### Solution process
Now we need to get the values meeting the condition (a valid repeating sequence)
- We will iterate over the pairs of `(k = num_characters, m = repetitions)` we found before
- For each k, we know all the possible values of length k:
    - `k = 2 -> 10..99`
    - `k = 3 -> 100..999`

But we have a constraint: the input range `(start, end)`. 
- we know that our candidate must satisfy `S = N / D`
- we need to find a range of valid numbers: 
    - `S >= start / d` -> Ceil (closest integer with reminder 0, rounding up, since it can't be smaller than the start range)
    - `S <= end / d` -> Floor (closest integer with reminder 0, rounding down, since it can't be greater than the end range)

#### Example
- input range: start = 1, end = 5000
- Pair (k = 2, m = 2) → total length l = k*m = 4
- d = 101
- s_min = 10/101 = 0.0099 -> 1
- s_max = 5000/101 = 49.5 -> 49
- This gives us a range `1..49`
- But, 1 is not in the k range `10..99` for k = 2, so we need to find the overlapping range: `10..49`. 
- This tells us: 
    - if you have a range (10, 5000), and a sequence of two numbers (k = 2) repeated twice (m = 2),
        then the sequence `10..99` is restricted to `10..49`. 
    - we can build all values consisting of a pair repeated 2 times from: 
        - `1212..4949`

### Almost finally
Now we know which values meet the condition for an input range `(start, end)` and a valid pair `(k, m)`.
But we need to build it and sum them.

- We know that each value N can be writen as N = S * D (the number N is a sequence S * D). 
- We know D, and S is just the range of values we get previously

For example, if the set of values is the range `10..12`, and d = 101: 
- sum_of_all = (10 * 101) + (11 * 101) + (12 * 101) = 101 * (10 + 11 + 12) 
- Which basically is (using the general case for gauss sumation for an arbitrary range): 
\[
\sum_{S={S_{\min}}}^{S_{\max}} S \cdot d = d \cdot \frac{(S_{\max} - S_{\min} + 1) \cdot (S_{\min} + S_{\max})}{2}
\]

And this is super nice because avoids iterating over the range.

So in principle, we are done:
- Iterate over all input ranges
- For each range, iterate over all valid (k, m) pairs
- Calculate the denominator D for N = S * D
- Calculate the bounds `(s_min, s_max)`
- Apply the sum over the range
- Add the sum for every pair, and then for every range
- Done!

Except! 
We have a bunch of repeated values!

For example, for range `(0..9999)`:
- for k = 2, m = 2, we could build 1111
- for k = 1, m = 4, we could build 1111

So 1111 is added twice!
Another example:
- `1234_1234_1234_1234_1234` is both: 
    - `1234 * 4` 
    - `1234_1234 * 2`

A naive solution would be to just use a Set and, 
instead of using the sumatory trick to calculate the sum at once, 
iterate over the possible S * D values, insert to the set if not there and sum all the values at the end. 
And this will work, and actually works in a reasonable amount of time for my AOC input. 
The problem is that for long ranges this is far away from being optimal. 


### Möbius function and PIE (Principle of Inclusion-Exclusion)

##### Möbius Function \(\mu(n)\)

The Möbius function is defined for positive integers \(n\) as:

\[
\mu(m) =
\begin{cases} 
1 & \text{if } m = 1, \\
0 & \text{if } m \text{ has a squared prime factor}, \\
(-1)^k & \text{if } m \text{ is a product of } k \text{ distinct primes}.
\end{cases}
\]

#### TODO